_         = require 'lodash'
path      = require 'path'
url       = require('url')
Q         = require 'q'
Abstract  = require './abstract'

SourceMapConsumer  = require('source-map').SourceMapConsumer
SourceMapGenerator = require('source-map').SourceMapGenerator
SourceNode         = require('source-map').SourceNode

###

options:
  * files     (String|[String]) required
  * cwd       (String)
  * destFile  (String) required
  * filter    (function)
  * options
    * sourceRoot  (string)  A root for all relative URLs in this source map

###
module.exports = class SourceMap extends Abstract

  onRun: (deferred, srcDestMap, options = {}) =>
    options     = _.defaults (options || {}), @getDefaultOptions()
    srcDestObjs = srcDestMap.resolve()

    @_ensureFolders(srcDestObjs, options)

    destMapping = {}
    _.each srcDestObjs, (srcDestObj) =>
      destMapping[srcDestObj.dest().path()] or= []
      destMapping[srcDestObj.dest().path()].push srcDestObj

    _.each destMapping, (srcDestObjs, destFile) => @_concat(srcDestObjs, destFile, options)

    deferred.resolve()

  _concat: (srcDestObjs, destFile, options) =>
    sourceMaps = []
    f       = {}
    f.src   = []
    f.dest  = destFile
    _.each srcDestObjs, (srcDestObj) =>
      f.src = f.src.concat(srcDestObj.src().pathFromRoot())

    # iterate files
    _.each [f], (file) =>
      destDir     = path.dirname(file.dest)
      sourceNode  = new SourceNode()

      # Warn on and remove invalid source files (if nonull was set).
      filepaths = file.src.filter (filepath) =>
        return true if @naspi.file.exists(filepath)

        @naspi.logger.writelnWarn("Source file \"#{filepath}\" not found.")
        false

      # Concatenate files with using SourceNode.
      filepaths.forEach (filename) =>
        # Read file source.
        relativeFilename  = path.relative(destDir, filename)
        src               = @naspi.file.read(filename)

        if _.isFunction(options.process)
          src = options.process(src, filename)

        if @hasSourcemapLine(src)
          sourceMappingURL = RegExp.$1
          sourceMapPath = path.resolve(path.dirname(filename), sourceMappingURL)
          sourceMap = JSON.parse(@naspi.file.read(sourceMapPath))

          # The source map generated by sass 3.3.0.rc.1 seems to be wrong format.
          sourceMap.version = parseInt(sourceMap.version, 10) if _.isString(sourceMap.version)
          sourceMap.names = [] if _.isUndefined(sourceMap.names)

          sourceMapConsumer = new SourceMapConsumer(sourceMap)
          sourcePathToSourceMapPath = path.relative(destDir, path.dirname(sourceMapPath))
          sourceMaps.push([sourceMapConsumer, relativeFilename, sourcePathToSourceMapPath])
          src = src.replace(/[@#]\s+sourceMappingURL=[^\s]+/, '')
          sourceNode.add(SourceNode.fromStringWithSourceMap(src, sourceMapConsumer, sourcePathToSourceMapPath))
        else
          childNodeChunks = src.split('\n')
          _.each childNodeChunks, (childNodeChunk, index) => childNodeChunks[index] += '\n'

          childNodeChunks.forEach (line, i) =>
            sourceNode.add(new SourceNode(i + 1, 0, relativeFilename, line))

          sourceNode.add(new SourceNode(1, 0, undefined, options.separator))
          sourceNode.setSourceContent(relativeFilename, src) if options.sourcesContent

      mapfilepath = file.dest.split('/').pop() + '.map'
      if /\.css$/.test(file.dest)
        sourceNode.add('/*# sourceMappingURL=' + mapfilepath + ' */')
      else
        sourceNode.add('//# sourceMappingURL=' + mapfilepath)

      code_map = sourceNode.toStringWithSourceMap
        file: file.dest
        sourceRoot: options.sourceRoot

      # Write the destination file.
      @naspi.file.write(file.dest, code_map.code)

      # Write the source map file.
      generator = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(code_map.map.toJSON()))
      sourceMaps.forEach (sourceMap) =>
        generator.applySourceMap(sourceMap[0], sourceMap[1], sourceMap[2])

      if options.sourcesContent
        sourceMaps.forEach (sourceMap) =>
          sourceMap[0].sources.forEach (source) =>
            generator.setSourceContent(source, @naspi.file.read(path.resolve(destDir, source)))

      newSourceMap = generator.toJSON()
      newSourceMap.file = path.basename(newSourceMap.file)
      @naspi.file.write(file.dest + '.map', JSON.stringify(newSourceMap, null, '  '))

      # Print a success message.
      @naspi.verbose.writeln "File \"#{file.dest}\" created."



  hasSourcemapLine: (src) =>
    return true if /\/\/[@#]\s+sourceMappingURL=(.+)/.test(src)
    /\/\*#\s+sourceMappingURL=([^\s]+)\s+\*\//.test(src)


  getDefaultOptions: ->
    separator: '\n'
    sourceRoot: ''
    sourcesContent: false
    process: undefined

  _ensureFolders: (srcDestObjs, options) =>
    _.each srcDestObjs, (srcDestObj) =>
      @naspi.file.mkdir(srcDestObj.dest().dirname())



